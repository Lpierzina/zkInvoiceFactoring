import { Request, Response } from "express";
import { AuthorizationCode } from "simple-oauth2";
import dotenv from "dotenv";
import fetch from "node-fetch";
import { execSync } from "child_process";
import path from "path";
import fs from "fs";

dotenv.config();

let quickBooksToken: any = null;
let quickBooksRealmId: string | null = null;

const client = new AuthorizationCode({
  client: {
    id: process.env.QUICKBOOKS_CLIENT_ID!,
    secret: process.env.QUICKBOOKS_CLIENT_SECRET!,
  },
  auth: {
    tokenHost: "https://oauth.platform.intuit.com",
    authorizePath: "/oauth2/v1/tokens/bearer",
    tokenPath: "/oauth2/v1/tokens/bearer",
  },
});

// Step 1: OAuth
export const startOAuth = (req: Request, res: Response) => {
  const authorizationUri = client.authorizeURL({
    redirect_uri: process.env.CALLBACK_URL!,
    scope: "com.intuit.quickbooks.accounting",
    state: Math.random().toString(36).substring(7),
  });
  res.redirect(authorizationUri);
};

// Step 2: OAuth callback
export const quickbooksCallback = async (req: Request, res: Response) => {
  const { code, realmId } = req.query;
  try {
    const accessToken = await client.getToken({
      code: code as string,
      redirect_uri: process.env.CALLBACK_URL!,
      scope: "com.intuit.quickbooks.accounting",
    });

    quickBooksToken = accessToken.token;
    quickBooksRealmId = realmId as string;
    console.log("QuickBooks token saved:", quickBooksToken, "RealmId:", quickBooksRealmId);

    res.send(`
      <h2>QuickBooks Connected!</h2>
      <p>You may now close this tab and return to the app.</p>
    `);
  } catch (error) {
    console.error("OAuth Callback Error", error);
    res.status(500).send("OAuth callback error: " + (error as any).message);
  }
};

// Step 3: ZK proof (with QuickBooks)
export const proveReliabilityWithQuickbooks = async (req: Request, res: Response) => {
  const { threshold_percent } = req.body;
  if (!quickBooksToken || !quickBooksRealmId) {
    return res.status(401).json({ error: "QuickBooks not connected." });
  }

  // Fetch invoice counts privately from QuickBooks
  const url = `https://quickbooks.api.intuit.com/v3/company/${quickBooksRealmId}/query?query=SELECT%20*%20FROM%20Invoice`;
  const accessToken = quickBooksToken.access_token;

  let total = 0, paid = 0;
  try {
    const qbRes = await fetch(url, {
      method: "GET",
      headers: {
        "Authorization": `Bearer ${accessToken}`,
        "Accept": "application/json",
        "Content-Type": "application/text",
      }
    });
    if (!qbRes.ok) throw new Error("QB fetch failed");
    const qbData = await qbRes.json() as any;
    const invoices = qbData.QueryResponse.Invoice || [];
    total = invoices.length;
    paid = invoices.filter((inv: any) => Number(inv.Balance) === 0).length;
  } catch (err) {
    console.error("QuickBooks fetch error:", err);
    return res.status(500).json({ error: "Failed to fetch invoices from QuickBooks" });
  }

  // Write TOML for Noir (no [main], just key=val)
  const toml = `total_invoices = ${total}\npaid_invoices = ${paid}\nthreshold_percent = ${threshold_percent}\n`;
  const proverPath = path.join(__dirname, "../../invoice_reliability/Prover.toml");
  fs.writeFileSync(proverPath, toml);

  try {
    const result = execSync('nargo execute', {
      cwd: path.join(__dirname, "../../invoice_reliability"),
    }).toString();

    const match = result.match(/Field\((\d)\)/);
    const isReliable = match ? match[1] === '1' : false;

    res.json({
      zk_proof: "Proof generated by Noir",
      isReliable,
      threshold_percent,
    });
  } catch (e) {
  let msg = "Unknown error";
  let nargoOutput = undefined;
  if (e instanceof Error) {
    msg = e.message;
    // @ts-ignore
    nargoOutput = (e as any).stdout?.toString();
  } else if (typeof e === "string") {
    msg = e;
  }
  res.status(500).json({ error: msg, nargoOutput });
}

};
